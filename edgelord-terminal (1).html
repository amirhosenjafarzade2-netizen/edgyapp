<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SYSTEM BREACH</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            cursor: none;
        }

        #cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #f00;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            mix-blend-mode: difference;
            transition: transform 0.1s;
        }

        #matrix {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.15;
            z-index: 1;
        }

        .container {
            position: relative;
            z-index: 2;
            height: 100vh;
            display: flex;
            padding: 20px;
            gap: 20px;
        }

        .sidebar {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .header {
            border: 2px solid #0f0;
            padding: 15px;
            margin-bottom: 20px;
            background: rgba(0, 255, 0, 0.05);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            animation: glitch 3s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }

        h1 {
            font-size: 1.5em;
            text-shadow: 0 0 10px #0f0, 0 0 20px #0f0;
            letter-spacing: 3px;
        }

        .status {
            color: #f00;
            font-size: 0.8em;
            margin-top: 10px;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .panel {
            border: 2px solid #0f0;
            padding: 15px;
            background: rgba(0, 20, 0, 0.9);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }

        .panel h2 {
            font-size: 1em;
            margin-bottom: 15px;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
            border-bottom: 1px solid #0f0;
            padding-bottom: 5px;
        }

        .cmd-button {
            display: block;
            width: 100%;
            background: #000;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 10px;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            pointer-events: auto;
        }

        .cmd-button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.6);
        }

        .cmd-button:active {
            transform: scale(0.98);
        }

        .terminal {
            flex: 1;
            border: 2px solid #0f0;
            padding: 20px;
            overflow-y: auto;
            background: rgba(0, 20, 0, 0.9);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.4);
            margin-bottom: 20px;
        }

        .terminal::-webkit-scrollbar {
            width: 10px;
        }

        .terminal::-webkit-scrollbar-track {
            background: #000;
        }

        .terminal::-webkit-scrollbar-thumb {
            background: #0f0;
        }

        .line {
            margin: 5px 0;
            text-shadow: 0 0 5px #0f0;
            word-wrap: break-word;
        }

        .error {
            color: #f00;
            text-shadow: 0 0 5px #f00;
        }

        .warning {
            color: #ff0;
            text-shadow: 0 0 5px #ff0;
        }

        .success {
            color: #0ff;
            text-shadow: 0 0 5px #0ff;
        }

        .input-area {
            display: flex;
            gap: 10px;
        }

        input[type="text"], input[type="file"] {
            flex: 1;
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            outline: none;
            pointer-events: auto;
        }

        input::placeholder {
            color: #0a0;
        }

        button {
            background: #000;
            border: 2px solid #0f0;
            color: #0f0;
            padding: 15px 30px;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            pointer-events: auto;
        }

        button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8);
        }

        .scan-line {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(to bottom, transparent, #0f0);
            animation: scan 4s linear infinite;
            z-index: 3;
            pointer-events: none;
        }

        @keyframes scan {
            0% { top: 0; }
            100% { top: 100%; }
        }

        .tools {
            flex: 1;
            overflow-y: auto;
        }

        .tools::-webkit-scrollbar {
            width: 8px;
        }

        .tools::-webkit-scrollbar-track {
            background: #000;
        }

        .tools::-webkit-scrollbar-thumb {
            background: #0f0;
        }

        .info-panel {
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.75em;
        }

        .info-panel::-webkit-scrollbar {
            width: 6px;
        }

        .info-panel::-webkit-scrollbar-track {
            background: #000;
        }

        .info-panel::-webkit-scrollbar-thumb {
            background: #0f0;
        }

        .info-line {
            margin: 3px 0;
            color: #0a0;
        }
    </style>
</head>
<body>
    <canvas id="matrix"></canvas>
    <div id="cursor"></div>
    <div class="scan-line"></div>
    
    <div class="container">
        <div class="sidebar">
            <div class="panel tools">
                <h2>‚ö° CRYPTOGRAPHY</h2>
                <button class="cmd-button" onclick="runCommand('caesar')">üîê CAESAR CIPHER</button>
                <button class="cmd-button" onclick="runCommand('rot13')">üîÑ ROT13</button>
                <button class="cmd-button" onclick="runCommand('encode')">üì¶ BASE64 ENCODE</button>
                <button class="cmd-button" onclick="runCommand('decode')">üìÇ BASE64 DECODE</button>
                <button class="cmd-button" onclick="runCommand('hash')"># SHA-256 HASH</button>
                <button class="cmd-button" onclick="runCommand('morse')">‚Ä¢‚àí‚Ä¢ MORSE CODE</button>
                <button class="cmd-button" onclick="runCommand('demorse')">‚àí‚Ä¢‚Ä¢ DECODE MORSE</button>
                <button class="cmd-button" onclick="runCommand('stego-encode')">üñºÔ∏è STEGO ENCODE</button>
                <button class="cmd-button" onclick="runCommand('stego-decode')">üñºÔ∏è STEGO DECODE</button>
                <button class="cmd-button" onclick="runCommand('exif')">üì∑ EXIF READER</button>
                
                <h2 style="margin-top: 15px;">üîß UTILITIES</h2>
                <button class="cmd-button" onclick="runCommand('ip')">üåê MY IP ADDRESS</button>
                <button class="cmd-button" onclick="runCommand('uuid')">üÜî GENERATE UUID</button>
                <button class="cmd-button" onclick="runCommand('password')">üîë PASSWORD GEN</button>
                <button class="cmd-button" onclick="runCommand('binary')">üíæ TEXT TO BINARY</button>
                <button class="cmd-button" onclick="runCommand('hex')">üîß TEXT TO HEX</button>
                <button class="cmd-button" onclick="runCommand('reverse')">‚ÜîÔ∏è REVERSE TEXT</button>
                <button class="cmd-button" onclick="runCommand('count')">üìä WORD COUNT</button>
                <button class="cmd-button" onclick="runCommand('leetspeak')">1337 LEETSPEAK</button>
                <button class="cmd-button" onclick="runCommand('ascii')">üé® ASCII ART</button>
                <button class="cmd-button" onclick="runCommand('time')">‚è∞ SYSTEM TIME</button>
                <button class="cmd-button" onclick="runCommand('sysinfo')">üíª SYSTEM INFO</button>
                <button class="cmd-button" onclick="runCommand('clear')">üóëÔ∏è CLEAR</button>
            </div>

            <div class="panel info-panel">
                <h2>üìä LIVE STATS</h2>
                <div id="infoDisplay"></div>
            </div>
        </div>

        <div class="main-content">
            <div class="header">
                <h1>‚ö† SYSTEM BREACH DETECTED ‚ö†</h1>
                <div class="status">[UNAUTHORIZED ACCESS] INTRUSION IN PROGRESS...</div>
            </div>

            <div class="terminal" id="terminal"></div>

            <div class="input-area">
                <input type="text" id="commandInput" placeholder="ENTER COMMAND OR PARAMETERS..." />
                <input type="file" id="imageInput" accept="image/jpeg,image/png" style="display: none;" />
                <button onclick="executeCommand()">EXECUTE</button>
            </div>
        </div>
    </div>

    <script>
        const startTime = Date.now();
        let waitingForInput = null;

        // Matrix rain effect
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const chars = 'ÔΩ±ÔΩ≤ÔΩ≥ÔΩ¥ÔΩµÔΩ∂ÔΩ∑ÔΩ∏ÔΩπÔΩ∫ÔΩªÔΩºÔΩΩÔΩæÔΩøÔæÄÔæÅÔæÇÔæÉÔæÑÔæÖÔæÜÔæáÔæàÔæâÔæäÔæãÔæåÔæçÔæéÔæèÔæêÔæëÔæíÔæìÔæîÔæïÔæñÔæóÔæòÔæôÔæöÔæõÔæúÔΩ¶Ôæù01';
        const fontSize = 14;
        const columns = canvas.width / fontSize;
        const drops = Array(Math.floor(columns)).fill(1);

        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0f0';
            ctx.font = fontSize + 'px monospace';

            for (let i = 0; i < drops.length; i++) {
                const text = chars[Math.floor(Math.random() * chars.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }

        setInterval(drawMatrix, 35);

        // Custom cursor
        document.addEventListener('mousemove', (e) => {
            const cursor = document.getElementById('cursor');
            cursor.style.left = e.clientX - 10 + 'px';
            cursor.style.top = e.clientY - 10 + 'px';
        });

        // Terminal functionality
        const terminal = document.getElementById('terminal');

        function addLine(text, className = '') {
            const line = document.createElement('div');
            line.className = 'line ' + className;
            line.textContent = '> ' + text;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
        }

        function updateInfo() {
            const info = document.getElementById('infoDisplay');
            const uptime = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(uptime / 60);
            const seconds = uptime % 60;
            info.innerHTML = `
                <div class="info-line">UPTIME: ${minutes}m ${seconds}s</div>
                <div class="info-line">BROWSER: ${navigator.userAgent.split(' ').slice(-2).join(' ')}</div>
                <div class="info-line">PLATFORM: ${navigator.platform}</div>
                <div class="info-line">SCREEN: ${screen.width}x${screen.height}</div>
                <div class="info-line">TIME: ${new Date().toLocaleTimeString()}</div>
            `;
        }

        function bootSequence() {
            const messages = [
                'INITIALIZING CRYPTOGRAPHIC MODULES...',
                'LOADING CIPHER ALGORITHMS...',
                'LOADING STEGANOGRAPHY MODULES...',
                'LOADING EXIF PARSERS...',
                { text: 'FIREWALL STATUS: BREACHED', className: 'error' },
                { text: 'ENCRYPTION: ACTIVE', className: 'warning' },
                'TERMINAL READY',
                { text: 'CLICK TOOLS OR TYPE COMMANDS', className: 'success' }
            ];

            messages.forEach((msg, i) => {
                setTimeout(() => {
                    if (typeof msg === 'string') {
                        addLine(msg);
                    } else {
                        addLine(msg.text, msg.className);
                    }
                }, i * 300);
            });
        }

        async function simpleHash(str) {
            const encoder = new TextEncoder();
            const data = encoder.encode(str);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        function caesarCipher(text, shift) {
            return text.split('').map(char => {
                if (char.match(/[a-z]/i)) {
                    const code = char.charCodeAt(0);
                    const base = code >= 65 && code <= 90 ? 65 : 97;
                    return String.fromCharCode(((code - base + shift) % 26 + 26) % 26 + base);
                }
                return char;
            }).join('');
        }

        function rot13(text) {
            return caesarCipher(text, 13);
        }

        function textToMorse(text) {
            const morse = {
                'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
                'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
                'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
                'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
                'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---',
                '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...',
                '8': '---..', '9': '----.', ' ': '/'
            };
            return text.toUpperCase().split('').map(c => morse[c] || c).join(' ');
        }

        function morseToText(morse) {
            const code = {
                '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', '..-.': 'F',
                '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', '-.-': 'K', '.-..': 'L',
                '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R',
                '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X',
                '-.--': 'Y', '--..': 'Z', '-----': '0', '.----': '1', '..---': '2',
                '...--': '3', '....-': '4', '.....': '5', '-....': '6', '--...': '7',
                '---..': '8', '----.': '9', '/': ' '
            };
            return morse.split(' ').map(c => code[c] || c).join('');
        }

        function generatePassword(length = 16) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
            let password = '';
            for (let i = 0; i < length; i++) {
                password += chars[Math.floor(Math.random() * chars.length)];
            }
            return password;
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function toLeetSpeak(text) {
            const leet = {
                'a': '4', 'e': '3', 'i': '1', 'o': '0', 's': '5', 't': '7', 'l': '1', 'g': '9'
            };
            return text.toLowerCase().split('').map(c => leet[c] || c).join('');
        }

        function asciiArt(text) {
            const art = {
                'A': [' ‚ñà‚ñà‚ñà‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà'],
                'B': ['‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà '],
                'C': [' ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '‚ñà‚ñà     ', '‚ñà‚ñà     ', '‚ñà‚ñà     ', ' ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà'],
                'D': ['‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà '],
                'E': ['‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '‚ñà‚ñà     ', '‚ñà‚ñà‚ñà‚ñà‚ñà  ', '‚ñà‚ñà     ', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà'],
                'F': ['‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '‚ñà‚ñà     ', '‚ñà‚ñà‚ñà‚ñà‚ñà  ', '‚ñà‚ñà     ', '‚ñà‚ñà     '],
                'G': [' ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '‚ñà‚ñà     ', '‚ñà‚ñà  ‚ñà‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', ' ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà'],
                'H': ['‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà'],
                'I': ['‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '   ‚ñà‚ñà  ', '   ‚ñà‚ñà  ', '   ‚ñà‚ñà  ', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà'],
                'J': ['     ‚ñà‚ñà', '     ‚ñà‚ñà', '     ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', ' ‚ñà‚ñà‚ñà‚ñà‚ñà '],
                'K': ['‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà  ‚ñà‚ñà ', '‚ñà‚ñà‚ñà‚ñà‚ñà  ', '‚ñà‚ñà  ‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà'],
                'L': ['‚ñà‚ñà     ', '‚ñà‚ñà     ', '‚ñà‚ñà     ', '‚ñà‚ñà     ', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà'],
                'M': ['‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà', '‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà', '‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà', '‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà', '‚ñà‚ñà      ‚ñà‚ñà'],
                'N': ['‚ñà‚ñà‚ñà    ‚ñà‚ñà', '‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà', '‚ñà‚ñà  ‚ñà‚ñà ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà‚ñà‚ñà'],
                'O': [' ‚ñà‚ñà‚ñà‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', ' ‚ñà‚ñà‚ñà‚ñà‚ñà '],
                'P': ['‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ', '‚ñà‚ñà     ', '‚ñà‚ñà     '],
                'Q': [' ‚ñà‚ñà‚ñà‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà  ‚ñà‚ñà ', ' ‚ñà‚ñà‚ñà‚ñà ‚ñà'],
                'R': ['‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà'],
                'S': ['‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '‚ñà‚ñà     ', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '     ‚ñà‚ñà', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà'],
                'T': ['‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '   ‚ñà‚ñà  ', '   ‚ñà‚ñà  ', '   ‚ñà‚ñà  ', '   ‚ñà‚ñà  '],
                'U': ['‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', '‚ñà‚ñà   ‚ñà‚ñà', ' ‚ñà‚ñà‚ñà‚ñà‚ñà '],
                'V': ['‚ñà‚ñà    ‚ñà‚ñà', '‚ñà‚ñà    ‚ñà‚ñà', '‚ñà‚ñà    ‚ñà‚ñà', ' ‚ñà‚ñà  ‚ñà‚ñà ', '  ‚ñà‚ñà‚ñà‚ñà  '],
                'W': ['‚ñà‚ñà      ‚ñà‚ñà', '‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà', '‚ñà‚ñà  ‚ñà‚ñà  ‚ñà‚ñà', '‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà', '‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà'],
                'X': ['‚ñà‚ñà   ‚ñà‚ñà', ' ‚ñà‚ñà ‚ñà‚ñà ', '  ‚ñà‚ñà‚ñà  ', ' ‚ñà‚ñà ‚ñà‚ñà ', '‚ñà‚ñà   ‚ñà‚ñà'],
                'Y': ['‚ñà‚ñà   ‚ñà‚ñà', ' ‚ñà‚ñà ‚ñà‚ñà ', '  ‚ñà‚ñà‚ñà  ', '   ‚ñà‚ñà  ', '   ‚ñà‚ñà  '],
                'Z': ['‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà', '    ‚ñà‚ñà ', '   ‚ñà‚ñà  ', '  ‚ñà‚ñà   ', '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà'],
                ' ': ['       ', '       ', '       ', '       ', '       ']
            };
            
            const lines = ['', '', '', '', ''];
            for (let char of text.toUpperCase()) {
                if (art[char]) {
                    for (let i = 0; i < 5; i++) {
                        lines[i] += art[char][i] + ' ';
                    }
                }
            }
            return lines.join('\n');
        }

        async function getIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (e) {
                return 'Unable to fetch IP';
            }
        }

        // Steganography functions
        function encodeStego(image, text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const textBits = textToBinary(text + '\0'); // Null terminator to mark end of text
            let bitIndex = 0;

            for (let i = 0; i < data.length && bitIndex < textBits.length; i += 4) {
                for (let channel = 0; channel < 3; channel++) { // R, G, B channels
                    if (bitIndex < textBits.length) {
                        data[i + channel] = (data[i + channel] & 0xFE) | parseInt(textBits[bitIndex]);
                        bitIndex++;
                    }
                }
            }

            if (bitIndex < textBits.length) {
                throw new Error('Image too small to encode the entire message');
            }

            ctx.putImageData(imageData, 0, 0);
            return canvas;
        }

        function decodeStego(image) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let bits = '';
            let text = '';

            for (let i = 0; i < data.length; i += 4) {
                for (let channel = 0; channel < 3; channel++) {
                    bits += (data[i + channel] & 1).toString();
                    if (bits.length === 8) {
                        const charCode = parseInt(bits, 2);
                        if (charCode === 0) { // Null terminator
                            return text;
                        }
                        text += String.fromCharCode(charCode);
                        bits = '';
                    }
                }
            }

            return text || 'No hidden message found';
        }

        function textToBinary(text) {
            return text.split('')
                .map(char => char.charCodeAt(0).toString(2).padStart(8, '0'))
                .join('');
        }

        function downloadCanvas(canvas, filename) {
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // EXIF reader function
        function readExif(file, callback) {
            EXIF.getData(file, function() {
                const allMetaData = EXIF.getAllTags(this);
                callback(allMetaData);
            });
        }

        function formatExifData(exifData) {
            if (Object.keys(exifData).length === 0) {
                return 'No EXIF data found';
            }
            const output = [];
            for (const [key, value] of Object.entries(exifData)) {
                if (key === 'GPSLatitude' || key === 'GPSLongitude') {
                    const [degrees, minutes, seconds] = value;
                    output.push(`${key}: ${degrees}¬∞ ${minutes}' ${seconds}"`);
                } else if (key === 'DateTimeOriginal') {
                    output.push(`DateTime: ${value}`);
                } else if (typeof value !== 'object') {
                    output.push(`${key}: ${value}`);
                }
            }
            return output.join('\n');
        }

        function runCommand(cmd) {
            const input = document.getElementById('commandInput');
            const imageInput = document.getElementById('imageInput');
            
            if (cmd === 'clear') {
                terminal.innerHTML = '';
                return;
            }

            addLine(cmd.toUpperCase(), 'warning');

            switch(cmd) {
                case 'time':
                    const now = new Date();
                    addLine(`CURRENT TIME: ${now.toLocaleTimeString()}`, 'success');
                    addLine(`CURRENT DATE: ${now.toLocaleDateString()}`, 'success');
                    addLine(`UNIX TIMESTAMP: ${Math.floor(now.getTime() / 1000)}`, 'success');
                    addLine(`ISO FORMAT: ${now.toISOString()}`, 'success');
                    break;

                case 'caesar':
                    waitingForInput = 'caesar';
                    addLine('CAESAR CIPHER - ENTER TEXT,SHIFT (e.g., HELLO,3):', 'success');
                    input.focus();
                    break;

                case 'rot13':
                    waitingForInput = 'rot13';
                    addLine('ROT13 CIPHER - ENTER TEXT:', 'success');
                    input.focus();
                    break;

                case 'encode':
                    waitingForInput = 'encode';
                    addLine('BASE64 ENCODER - ENTER TEXT:', 'success');
                    input.focus();
                    break;

                case 'decode':
                    waitingForInput = 'decode';
                    addLine('BASE64 DECODER - ENTER BASE64:', 'success');
                    input.focus();
                    break;

                case 'hash':
                    waitingForInput = 'hash';
                    addLine('SHA-256 HASH - ENTER TEXT:', 'success');
                    input.focus();
                    break;

                case 'morse':
                    waitingForInput = 'morse';
                    addLine('MORSE CODE ENCODER - ENTER TEXT:', 'success');
                    input.focus();
                    break;

                case 'demorse':
                    waitingForInput = 'demorse';
                    addLine('MORSE CODE DECODER - ENTER MORSE (use . and -):', 'success');
                    input.focus();
                    break;

                case 'stego-encode':
                    waitingForInput = 'stego-encode';
                    addLine('STEGO ENCODE - UPLOAD IMAGE AND ENTER TEXT:', 'success');
                    imageInput.style.display = 'block';
                    input.placeholder = 'ENTER TEXT TO HIDE...';
                    imageInput.click();
                    break;

                case 'stego-decode':
                    waitingForInput = 'stego-decode';
                    addLine('STEGO DECODE - UPLOAD IMAGE:', 'success');
                    imageInput.style.display = 'block';
                    imageInput.click();
                    break;

                case 'exif':
                    waitingForInput = 'exif';
                    addLine('EXIF READER - UPLOAD IMAGE:', 'success');
                    imageInput.style.display = 'block';
                    imageInput.click();
                    break;

                case 'password':
                    const pwd = generatePassword();
                    addLine(`GENERATED PASSWORD: ${pwd}`, 'success');
                    addLine(`LENGTH: ${pwd.length} characters`, 'success');
                    addLine(`ENTROPY: HIGH - Contains uppercase, lowercase, numbers, symbols`, 'success');
                    break;

                case 'uuid':
                    const uuid = generateUUID();
                    addLine(`GENERATED UUID: ${uuid}`, 'success');
                    addLine(`VERSION: 4 (Random)`, 'success');
                    break;

                case 'reverse':
                    waitingForInput = 'reverse';
                    addLine('TEXT REVERSER - ENTER TEXT:', 'success');
                    input.focus();
                    break;

                case 'binary':
                    waitingForInput = 'binary';
                    addLine('BINARY CONVERTER - ENTER TEXT:', 'success');
                    input.focus();
                    break;

                case 'hex':
                    waitingForInput = 'hex';
                    addLine('HEX CONVERTER - ENTER TEXT:', 'success');
                    input.focus();
                    break;

                case 'count':
                    waitingForInput = 'count';
                    addLine('WORD COUNTER - ENTER TEXT:', 'success');
                    input.focus();
                    break;

                case 'leetspeak':
                    waitingForInput = 'leetspeak';
                    addLine('LEETSPEAK CONVERTER - ENTER TEXT:', 'success');
                    input.focus();
                    break;

                case 'ascii':
                    waitingForInput = 'ascii';
                    addLine('ASCII ART - ENTER TEXT (SHORT!):', 'success');
                    input.focus();
                    break;

                case 'ip':
                    addLine('RETRIEVING IP ADDRESS...', 'warning');
                    getIP().then(ip => {
                        addLine(`YOUR IP: ${ip}`, 'success');
                    });
                    break;

                case 'sysinfo':
                    addLine(`BROWSER: ${navigator.userAgent}`, 'success');
                    addLine(`PLATFORM: ${navigator.platform}`, 'success');
                    addLine(`LANGUAGE: ${navigator.language}`, 'success');
                    addLine(`SCREEN: ${screen.width}x${screen.height}`, 'success');
                    addLine(`COLOR DEPTH: ${screen.colorDepth}-bit`, 'success');
                    addLine(`MEMORY: ${navigator.deviceMemory || 'N/A'} GB`, 'success');
                    addLine(`CPU CORES: ${navigator.hardwareConcurrency || 'N/A'}`, 'success');
                    addLine(`ONLINE: ${navigator.onLine ? 'YES' : 'NO'}`, 'success');
                    break;

                default:
                    addLine('ERROR: UNKNOWN COMMAND', 'error');
            }
        }

        function executeCommand() {
            const input = document.getElementById('commandInput');
            const imageInput = document.getElementById('imageInput');
            const value = input.value.trim();
            
            if (!value && waitingForInput !== 'stego-decode' && waitingForInput !== 'exif') return;

            if (waitingForInput) {
                addLine(value, 'warning');
                
                try {
                    switch(waitingForInput) {
                        case 'caesar':
                            const [caesarText, shift] = value.split(',');
                            const caesarResult = caesarCipher(caesarText, parseInt(shift) || 3);
                            addLine(`ENCRYPTED: ${caesarResult}`, 'success');
                            break;

                        case 'rot13':
                            const rot13Result = rot13(value);
                            addLine(`ROT13: ${rot13Result}`, 'success');
                            break;

                        case 'encode':
                            const encoded = btoa(value);
                            addLine(`BASE64: ${encoded}`, 'success');
                            break;

                        case 'decode':
                            const decoded = atob(value);
                            addLine(`DECODED: ${decoded}`, 'success');
                            break;

                        case 'hash':
                            simpleHash(value).then(hash => {
                                addLine(`SHA-256: ${hash}`, 'success');
                            });
                            break;

                        case 'morse':
                            const morseCode = textToMorse(value);
                            addLine(`MORSE: ${morseCode}`, 'success');
                            break;

                        case 'demorse':
                            const morseDecoded = morseToText(value);
                            addLine(`DECODED: ${morseDecoded}`, 'success');
                            break;

                        case 'stego-encode':
                            if (imageInput.files.length === 0) {
                                addLine('ERROR: NO IMAGE UPLOADED', 'error');
                            } else {
                                const file = imageInput.files[0];
                                const img = new Image();
                                img.onload = () => {
                                    try {
                                        const canvas = encodeStego(img, value);
                                        addLine('MESSAGE ENCODED IN IMAGE', 'success');
                                        addLine('DOWNLOADING STEGO IMAGE...', 'warning');
                                        downloadCanvas(canvas, 'stego-image.png');
                                    } catch (e) {
                                        addLine(`ERROR: ${e.message}`, 'error');
                                    }
                                };
                                img.src = URL.createObjectURL(file);
                            }
                            break;

                        case 'stego-decode':
                            if (imageInput.files.length === 0) {
                                addLine('ERROR: NO IMAGE UPLOADED', 'error');
                            } else {
                                const file = imageInput.files[0];
                                const img = new Image();
                                img.onload = () => {
                                    try {
                                        const message = decodeStego(img);
                                        addLine(`HIDDEN MESSAGE: ${message}`, 'success');
                                    } catch (e) {
                                        addLine(`ERROR: ${e.message}`, 'error');
                                    }
                                };
                                img.src = URL.createObjectURL(file);
                            }
                            break;

                        case 'exif':
                            if (imageInput.files.length === 0) {
                                addLine('ERROR: NO IMAGE UPLOADED', 'error');
                            } else {
                                const file = imageInput.files[0];
                                readExif(file, (exifData) => {
                                    const formattedData = formatExifData(exifData);
                                    addLine('EXIF DATA:', 'success');
                                    formattedData.split('\n').forEach(line => {
                                        addLine(line, 'success');
                                    });
                                });
                            }
                            break;

                        case 'reverse':
                            const reversed = value.split('').reverse().join('');
                            addLine(`REVERSED: ${reversed}`, 'success');
                            break;

                        case 'binary':
                            const binary = value.split('').map(c => 
                                c.charCodeAt(0).toString(2).padStart(8, '0')
                            ).join(' ');
                            addLine(`BINARY: ${binary}`, 'success');
                            break;

                        case 'hex':
                            const hex = value.split('').map(c => 
                                c.charCodeAt(0).toString(16).toUpperCase()
                            ).join(' ');
                            addLine(`HEX: ${hex}`, 'success');
                            break;

                        case 'count':
                            const words = value.trim().split(/\s+/).length;
                            const chars = value.length;
                            const charsNoSpace = value.replace(/\s/g, '').length;
                            addLine(`WORDS: ${words}`, 'success');
                            addLine(`CHARACTERS: ${chars}`, 'success');
                            addLine(`CHARACTERS (NO SPACE): ${charsNoSpace}`, 'success');
                            break;

                        case 'leetspeak':
                            const leet = toLeetSpeak(value);
                            addLine(`1337: ${leet}`, 'success');
                            break;

                        case 'ascii':
                            if (value.length > 10) {
                                addLine('TEXT TOO LONG! MAX 10 CHARS', 'error');
                            } else {
                                const ascii = asciiArt(value);
                                addLine('ASCII ART:', 'success');
                                ascii.split('\n').forEach(line => {
                                    addLine(line, 'success');
                                });
                            }
                            break;
                    }
                } catch (e) {
                    addLine(`ERROR: ${e.message}`, 'error');
                }
                
                waitingForInput = null;
                imageInput.style.display = 'none';
                input.placeholder = 'ENTER COMMAND OR PARAMETERS...';
                input.value = '';
                imageInput.value = '';
            } else {
                runCommand(value.toLowerCase());
                input.value = '';
            }
        }

        document.getElementById('commandInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                executeCommand();
            }
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        bootSequence();
        updateInfo();
        setInterval(updateInfo, 1000);
    </script>
</body>
</html>