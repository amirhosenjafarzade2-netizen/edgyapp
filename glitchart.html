<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Glitch Art Studio Pro</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    @keyframes glitch {
      0%, 100% { text-shadow: 2px 2px #ff00de, -2px -2px #00fff9; }
      25% { text-shadow: -2px 2px #ff00de, 2px -2px #00fff9; }
      50% { text-shadow: 2px -2px #ff00de, -2px 2px #00fff9; }
      75% { text-shadow: -2px -2px #ff00de, 2px 2px #00fff9; }
    }
    
    @keyframes scanline {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100vh); }
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 50%, #0a1a1a 100%);
      color: #00fff9;
      min-height: 100vh;
      padding: 20px;
      line-height: 1.6;
      position: relative;
      overflow-x: hidden;
    }
    
    .scanline {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 2px;
      background: linear-gradient(transparent, rgba(0,255,249,0.3), transparent);
      animation: scanline 4s linear infinite;
      pointer-events: none;
      z-index: 1000;
    }
    
    h1 { 
      text-align: center; 
      margin-bottom: 30px; 
      color: #ff00de;
      font-size: 2.5em;
      animation: glitch 2s infinite;
      text-transform: uppercase;
      letter-spacing: 4px;
    }
    
    .container { max-width: 1400px; margin: 0 auto; }
    
    .upload-area {
      border: 3px dashed #ff00de;
      border-radius: 15px;
      padding: 50px;
      text-align: center;
      margin-bottom: 30px;
      cursor: pointer;
      transition: all 0.3s;
      background: rgba(255,0,222,0.05);
      position: relative;
      overflow: hidden;
    }
    
    .upload-area::before {
      content: '';
      position: absolute;
      top: -50%; left: -50%;
      width: 200%; height: 200%;
      background: linear-gradient(45deg, transparent, rgba(0,255,249,0.1), transparent);
      transform: rotate(45deg);
      transition: all 0.5s;
    }
    
    .upload-area:hover::before { left: 100%; }
    .upload-area:hover { background: rgba(255,0,222,0.15); border-color: #00fff9; transform: scale(1.02); }
    .upload-area.dragover { background: rgba(0,255,249,0.2); border-color: #00fff9; box-shadow: 0 0 30px rgba(0,255,249,0.5); }
    .upload-area.loading { pointer-events: none; opacity: 0.7; }
    .upload-area.loading::after {
      content: '';
      position: absolute;
      top: 50%; left: 50%;
      width: 40px; height: 40px;
      margin: -20px 0 0 -20px;
      border: 4px solid #ff00de;
      border-top-color: #00fff9;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    
    #file-input { display: none; }
    
    .main-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }
    @media (max-width: 1000px) { .main-grid { grid-template-columns: 1fr; } }
    
    .canvas-section {
      background: rgba(0,0,0,0.5);
      padding: 20px;
      border-radius: 15px;
      border: 1px solid #ff00de;
    }
    .canvas-section h3 {
      color: #00fff9;
      margin-bottom: 15px;
      text-align: center;
      font-size: 1.2em;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    .canvas-wrapper {
      position: relative;
      width: 100%;
      min-height: 300px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
    }
    canvas { max-width: 100%; max-height: 500px; display: block; image-rendering: auto; }
    
    .controls {
      background: rgba(0,0,0,0.7);
      padding: 25px;
      border-radius: 15px;
      margin-bottom: 20px;
      border: 1px solid #00fff9;
      backdrop-filter: blur(10px);
    }
    
    .presets {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin-bottom: 25px;
    }
    .preset-btn {
      background: linear-gradient(135deg, #ff00de 0%, #00fff9 100%);
      color: #000;
      border: none;
      padding: 12px 15px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      border-radius: 8px;
      transition: all 0.3s;
      text-transform: uppercase;
      font-size: 0.85em;
      letter-spacing: 1px;
    }
    .preset-btn:hover {
      transform:: translateY(-2px);
      box-shadow: 0 5px 20px rgba(255,0,222,0.5);
    }
    
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .control-group {
      background: rgba(255,0,222,0.1);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid rgba(255,0,222,0.3);
    }
    
    label { 
      display: block; 
      margin-bottom: 8px; 
      color: #00fff9;
      font-size: 0.9em;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .value { float: right; color: #ff00de; font-weight: bold; }
    
    input[type="range"] { 
      width: 100%;
      height: 6px;
      background: linear-gradient(to right, #ff00de, #00fff9);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px; height: 18px;
      background: #00fff9;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0,255,249,0.8);
    }
    input[type="range"]::-moz-range-thumb {
      width: 18px; height: 18px;
      background: #00fff9;
      border-radius: 50%;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(0,255,249,0.8);
    }
    
    input[type="checkbox"] { margin-right: 8px; cursor: pointer; }
    
    .toggle-group {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 15px;
    }
    .toggle-item {
      display: flex;
      align-items: center;
      color: #00fff9;
    }
    
    textarea {
      width: 100%;
      height: 120px;
      background: #000;
      color: #00fff9;
      border: 1px solid #ff00de;
      padding: 10px;
      font-family: 'Courier New', monospace;
      margin-top: 10px;
      border-radius: 8px;
      resize: vertical;
    }
    
    .action-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 20px 0;
    }
    
    button {
      background: linear-gradient(135deg, rgba(255,0,222,0.2), rgba(0,255,249,0.2));
      color: #00fff9;
      border: 2px solid #00fff9;
      padding: 12px 30px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      border-radius: 8px;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 2px;
      position: relative;
      overflow: hidden;
    }
    button::before {
      content: '';
      position: absolute;
      top: 50%; left: 50%;
      width: 0; height: 0;
      background: rgba(0,255,249,0.3);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.5s, height 0.5s;
    }
    button:hover::before { width: 300px; height: 300px; }
    button:hover {
      border-color: #ff00de;
      color: #ff00de;
      box-shadow: 0 0 20px rgba(255,0,222,0.5);
      transform: translateY(-2px);
    }
    button span { position: relative; z-index: 1; }
    .primary-btn {
      background: linear-gradient(135deg, #ff00de, #00fff9);
      color: #000;
      border: none;
    }
    
    .stats {
      display: flex;
      justify-content: space-around;
      gap: 15px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    .stat-box {
      background: rgba(0,255,249,0.1);
      padding: 15px 25px;
      border-radius: 10px;
      border: 1px solid #00fff9;
      text-align: center;
      flex: 1;
      min-width: 150px;
    }
    .stat-label { font-size: 0.8em; color: #ff00de; text-transform: uppercase; letter-spacing: 1px; }
    .stat-value { font-size: 1.5em; color: #00fff9; font-weight: bold; margin-top: 5px; }
    
    .error { color: #ff0066; text-align: center; margin: 15px 0; padding: 10px; background: rgba(255,0,102,0.1); border-radius: 8px; border: 1px solid #ff0066; }
    .success { color: #00ff66; text-align: center; margin: 15px 0; padding: 10px; background: rgba(0,255,102,0.1); border-radius: 8px; border: 1px solid #00ff66; }
  </style>
</head>
<body>
  <div class="scanline"></div>
  
  <div class="container">
    <h1>GLITCH ART STUDIO PRO</h1>

    <div class="upload-area" id="drop-area">
      <h2 style="margin-bottom: 10px;">UPLOAD YOUR IMAGE</h2>
      <p>Drag & drop or click to select</p>
      <input type="file" id="file-input" accept="image/*" />
    </div>

    <div class="stats" id="stats" style="display: none;">
      <div class="stat-box"><div class="stat-label">Dimensions</div><div class="stat-value" id="dimensions">-</div></div>
      <div class="stat-box"><div class="stat-label">File Size</div><div class="stat-value" id="filesize">-</div></div>
      <div class="stat-box"><div class="stat-label">Processing Time</div><div class="stat-value" id="process-time">-</div></div>
    </div>

    <div class="main-grid">
      <div class="canvas-section">
        <h3>ORIGINAL</h3>
        <div class="canvas-wrapper"><canvas id="original-canvas"></canvas></div>
      </div>
      <div class="canvas-section">
        <h3>GLITCHED</h3>
        <div class="canvas-wrapper"><canvas id="glitch-canvas"></canvas></div>
      </div>
    </div>

    <div class="controls">
      <h3 style="color: #ff00de; margin-bottom: 15px; text-align: center;">QUICK PRESETS</h3>
      <div class="presets">
        <button class="preset-btn" data-preset="vaporwave"><span>Vaporwave</span></button>
        <button class="preset-btn" data-preset="corrupted"><span>Corrupted</span></button>
        <button class="preset-btn" data-preset="cyberpunk"><span>Cyberpunk</span></button>
        <button class="preset-btn" data-preset="vhs"><span>VHS Tape</span></button>
        <button class="preset-btn" data-preset="datamosh"><span>Datamosh</span></button>
        <button class="preset-btn" data-preset="analog"><span>Analog TV</span></button>
      </div>

      <h3 style="color: #ff00de; margin: 25px 0 15px; text-align: center;">ADVANCED CONTROLS</h3>
      
      <div class="controls-grid">
        <!-- Master Intensity -->
        <div class="control-group">
          <label>Intensity: <span class="value" id="intensity-val">100</span>%</label>
          <input type="range" id="intensity" min="0" max="200" value="100" />
        </div>

        <!-- RGB Shift -->
        <div class="control-group">
          <label>RGB Shift: <span class="value" id="rgb-val">25</span></label>
          <input type="range" id="rgb-shift" min="0" max="100" value="25" />
        </div>

        <!-- Byte Corruption -->
        <div class="control-group">
          <label>Byte Corruption: <span class="value" id="corrupt-val">1000</span></label>
          <input type="range" id="corrupt-intensity" min="0" max="20000" value="1000" />
        </div>

        <!-- Pixel Sort -->
        <div class="control-group">
          <label>Pixel Sort: <span class="value" id="sort-val">128</span></label>
          <input type="range" id="sort-threshold" min="0" max="255" value="128" />
        </div>

        <!-- Datamosh -->
        <div class="control-group">
          <label>Datamosh Power: <span class="value" id="mosh-val">10</span></label>
          <input type="range" id="mosh-strength" min="0" max="50" value="10" step="1" />
        </div>

        <!-- Scan Lines -->
        <div class="control-group">
          <label>Scan Lines: <span class="value" id="scan-val">5</span></label>
          <input type="range" id="scan-lines" min="0" max="15" value="5" step="1" />
        </div>

        <!-- Chromatic Aberration -->
        <div class="control-group">
          <label>Chromatic Aberration: <span class="value" id="chroma-val">15</span></label>
          <input type="range" id="chromatic" min="0" max="50" value="15" />
        </div>

        <!-- Noise Intensity -->
        <div class="control-group">
          <label>Noise Intensity: <span class="value" id="noise-val">30</span></label>
          <input type="range" id="noise-intensity" min="0" max="100" value="30" />
        </div>

        <!-- VHS Bleed -->
        <div class="control-group">
          <label>VHS Bleed: <span class="value" id="vhs-val">5</span></label>
          <input type="range" id="vhs-bleed" min="0" max="20" value="5" />
        </div>

        <!-- Wave Distortion -->
        <div class="control-group">
          <label>Wave Freq: <span class="value" id="wave-freq-val">15</span></label>
          <input type="range" id="wave-freq" min="1" max="50" value="15" />
        </div>
        <div class="control-group">
          <label>Wave Amp: <span class="value" id="wave-amp-val">20</span></label>
          <input type="range" id="wave-amp" min="0" max="60" value="20" />
        </div>
        <div class="control-group">
          <label>Wave Speed: <span class="value" id="wave-speed-val">1</span></label>
          <input type="range" id="wave-speed" min="0" max="5" value="1" step="0.1" />
        </div>

        <!-- Pixelation -->
        <div class="control-group">
          <label>Pixelation: <span class="value" id="pixelate-val">1</span></label>
          <input type="range" id="pixelate" min="1" max="50" value="1" />
        </div>

        <!-- Contrast & Brightness -->
        <div class="control-group">
          <label>Contrast: <span class="value" id="contrast-val">100</span></label>
          <input type="range" id="contrast" min="0" max="200" value="100" />
        </div>
        <div class="control-group">
          <label>Brightness: <span class="value" id="brightness-val">100</span></label>
          <input type="range" id="brightness" min="0" max="200" value="100" />
        </div>

        <!-- RGB Gains -->
        <div class="control-group">
          <label>Red Gain: <span class="value" id="red-gain-val">100</span></label>
          <input type="range" id="red-gain" min="0" max="200" value="100" />
        </div>
        <div class="control-group">
          <label>Green Gain: <span class="value" id="green-gain-val">100</span></label>
          <input type="range" id="green-gain" min="0" max="200" value="100" />
        </div>
        <div class="control-group">
          <label>Blue Gain: <span class="value" id="blue-gain-val">100</span></label>
          <input type="range" id="blue-gain" min="0" max="200" value="100" />
        </div>

        <!-- Vignette -->
        <div class="control-group">
          <label>Vignette: <span class="value" id="vignette-val">0</span></label>
          <input type="range" id="vignette" min="0" max="100" value="0" />
        </div>

        <!-- Sharpen & Blur -->
        <div class="control-group">
          <label>Sharpen: <span class="value" id="sharpen-val">0</span></label>
          <input type="range" id="sharpen" min="0" max="100" value="0" />
        </div>
        <div class="control-group">
          <label>Blur: <span class="value" id="blur-val">0</span></label>
          <input type="range" id="blur" min="0" max="20" value="0" />
        </div>

        <!-- JPEG Quality -->
        <div class="control-group">
          <label>JPEG Quality: <span class="value" id="jpg-quality-val">95</span></label>
          <input type="range" id="jpg-quality" min="10" max="100" value="95" />
        </div>
      </div>

      <div class="toggle-group">
        <div class="toggle-item"><input type="checkbox" id="enable-noise" checked /><label for="enable-noise" style="margin: 0;">Digital Noise</label></div>
        <div class="toggle-item"><input type="checkbox" id="enable-vhs" /><label for="enable-vhs" style="margin: 0;">VHS Effect</label></div>
        <div class="toggle-item"><input type="checkbox" id="enable-invert" /><label for="enable-invert" style="margin: 0;">Color Invert</label></div>
        <div class="toggle-item"><input type="checkbox" id="real-time" /><label for="real-time" style="margin: 0;">Real-time Preview</label></div>
      </div>

      <div class="control-group" style="margin-top: 20px;">
        <label for="custom-code">Custom Glitch Script (JavaScript)</label>
        <textarea id="custom-code" placeholder="// Access: ctx, imgData, width, height
function customGlitch(ctx, imgData, width, height) {
  // Your custom effect code here
}"></textarea>
      </div>
    </div>

    <div class="action-buttons">
      <button class="primary-btn" id="apply-glitch"><span>APPLY GLITCH</span></button>
      <button id="random-glitch"><span>RANDOMIZE</span></button>
      <button id="reset"><span>RESET</span></button>
      <button id="download-btn" style="display:none;"><span>DOWNLOAD PNG</span></button>
      <button id="download-jpg" style="display:none;"><span>DOWNLOAD JPG</span></button>
    </div>

    <p class="error" id="error-msg"></p>
    <p class="success" id="success-msg"></p>
  </div>

  <script>
    // === DOM ELEMENTS ===
    const dropArea = document.getElementById('drop-area');
    const fileInput = document.getElementById('file-input');
    const originalCanvas = document.getElementById('original-canvas');
    const glitchCanvas = document.getElementById('glitch-canvas');
    const downloadBtn = document.getElementById('download-btn');
    const downloadJpg = document.getElementById('download-jpg');
    const errorMsg = document.getElementById('error-msg');
    const successMsg = document.getElementById('success-msg');
    const stats = document.getElementById('stats');

    let originalImage = null;
    let currentGlitchData = null;
    let realTimeTimeout = null;
    let waveTime = 0;

    // === PRESETS (UPDATED) ===
    const presets = {
      vaporwave: { intensity: 120, rgbShift: 40, corrupt: 3000, sort: 180, mosh: 8, scan: 6, chromatic: 25, noise: 40, vhsBleed: 8, waveFreq: 20, waveAmp: 15, waveSpeed: 0.5, pixelate: 1, contrast: 130, brightness: 110, redGain: 120, greenGain: 100, blueGain: 140, vignette: 30, sharpen: 10, blur: 0, enableNoise: true, enableVhs: false, enableInvert: false },
      corrupted: { intensity: 180, rgbShift: 80, corrupt: 15000, sort: 50, mosh: 30, scan: 10, chromatic: 40, noise: 70, vhsBleed: 15, waveFreq: 30, waveAmp: 40, waveSpeed: 2, pixelate: 8, contrast: 150, brightness: 80, redGain: 150, greenGain: 50, blueGain: 200, vignette: 60, sharpen: 0, blur: 2, enableNoise: true, enableVhs: false, enableInvert: false },
      cyberpunk: { intensity: 140, rgbShift: 50, corrupt: 5000, sort: 200, mosh: 12, scan: 8, chromatic: 30, noise: 50, vhsBleed: 10, waveFreq: 25, waveAmp: 20, waveSpeed: 1, pixelate: 1, contrast: 140, brightness: 100, redGain: 100, greenGain: 130, blueGain: 180, vignette: 40, sharpen: 20, blur: 0, enableNoise: true, enableVhs: false, enableInvert: false },
      vhs: { intensity: 100, rgbShift: 15, corrupt: 2000, sort: 100, mosh: 10, scan: 12, chromatic: 20, noise: 30, vhsBleed: 18, waveFreq: 10, waveAmp: 10, waveSpeed: 0.3, pixelate: 2, contrast: 90, brightness: 110, redGain: 110, greenGain: 90, blueGain: 80, vignette: 50, sharpen: 0, blur: 3, enableNoise: true, enableVhs: true, enableInvert: false },
      datamosh: { intensity: 150, rgbShift: 30, corrupt: 4000, sort: 150, mosh: 45, scan: 3, chromatic: 25, noise: 20, vhsBleed: 5, waveFreq: 40, waveAmp: 30, waveSpeed: 3, pixelate: 1, contrast: 110, brightness: 100, redGain: 100, greenGain: 100, blueGain: 100, vignette: 0, sharpen: 0, blur: 1, enableNoise: false, enableVhs: false, enableInvert: false },
      analog: { intensity: 110, rgbShift: 10, corrupt: 3000, sort: 120, mosh: 15, scan: 14, chromatic: 15, noise: 60, vhsBleed: 20, waveFreq: 15, waveAmp: 25, waveSpeed: 0.8, pixelate: 3, contrast: 120, brightness: 90, redGain: 130, greenGain: 80, blueGain: 70, vignette: 70, sharpen: 5, blur: 2, enableNoise: true, enableVhs: true, enableInvert: false }
    };

    // === UPLOAD HANDLING ===
    function setupUploadHandlers() {
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false);
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, () => dropArea.classList.add('dragover'), false);
      });

      ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, () => dropArea.classList.remove('dragover'), false);
      });

      dropArea.addEventListener('drop', handleDrop);
      dropArea.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', () => handleFiles(fileInput.files));
    }

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt?.files;
      if (files) handleFiles(files);
    }

    function handleFiles(files) {
      if (!files || files.length === 0) return;
      const file = files[0];
      if (!file.type.startsWith('image/')) {
        showError('Please upload a valid image file.');
        return;
      }
      if (file.size > 50 * 1024 * 1024) {
        showError('Image too large. Max 50MB.');
        return;
      }

      showLoading(true);
      const reader = new FileReader();
      reader.onload = (e) => loadImage(e.target.result, file);
      reader.onerror = () => { showLoading(false); showError('Failed to read file.'); };
      reader.readAsDataURL(file);
    }

    function loadImage(src, file) {
      const img = new Image();
      img.onload = () => {
        originalImage = img;
        const fileSizeKB = (file.size / 1024).toFixed(2);
        document.getElementById('filesize').textContent = fileSizeKB + ' KB';
        document.getElementById('dimensions').textContent = `${img.width} × ${img.height}`;
        stats.style.display = 'flex';
        drawOriginal();
        resetGlitch();
        downloadBtn.style.display = 'none';
        downloadJpg.style.display = 'none';
        showLoading(false);
        showSuccess('Image loaded successfully!');
        setTimeout(() => showSuccess(''), 2000);
      };
      img.onerror = () => { showLoading(false); showError('Failed to load image.'); };
      img.src = src;
    }

    function showLoading(isLoading) {
      dropArea.classList.toggle('loading', isLoading);
    }

    // === CANVAS ===
    function drawOriginal() {
      const ctx = originalCanvas.getContext('2d');
      const scale = Math.min(600 / originalImage.width, 500 / originalImage.height, 1);
      const w = originalImage.width * scale;
      const h = originalImage.height * scale;
      originalCanvas.width = w;
      originalCanvas.height = h;
      ctx.drawImage(originalImage, 0, 0, w, h);
    }

    function resetGlitch() {
      const ctx = glitchCanvas.getContext('2d');
      const scale = Math.min(600 / originalImage.width, 500 / originalImage.height, 1);
      const w = originalImage.width * scale;
      const h = originalImage.height * scale;
      glitchCanvas.width = w;
      glitchCanvas.height = h;
      ctx.drawImage(originalImage, 0, 0, w, h);
      document.getElementById('process-time').textContent = '0 ms';
    }

    // === GLITCH ENGINE ===
    function applyGlitch() {
      if (!originalImage) return;
      showError('');
      const startTime = performance.now();

      const scale = Math.min(600 / originalImage.width, 500 / originalImage.height, 1);
      const w = originalImage.width * scale;
      const h = originalImage.height * scale;

      glitchCanvas.width = w;
      glitchCanvas.height = h;
      const ctx = glitchCanvas.getContext('2d');
      ctx.drawImage(originalImage, 0, 0, w, h);

      let imgData = ctx.getImageData(0, 0, w, h);
      const data = imgData.data;

      const intensity = parseInt(document.getElementById('intensity').value) / 100;

      // Scale base values by intensity
      const rgbShift = parseInt(document.getElementById('rgb-shift').value) * intensity;
      const corruptCount = parseInt(document.getElementById('corrupt-intensity').value) * intensity;
      const threshold = parseInt(document.getElementById('sort-threshold').value);
      const moshStrength = parseInt(document.getElementById('mosh-strength').value) * intensity;
      const chromatic = parseInt(document.getElementById('chromatic').value) * intensity;
      const noiseIntensity = parseInt(document.getElementById('noise-intensity').value) / 100 * intensity;
      const vhsBleed = parseInt(document.getElementById('vhs-bleed').value) * intensity;
      const scanLines = parseInt(document.getElementById('scan-lines').value);
      const waveFreq = parseFloat(document.getElementById('wave-freq').value);
      const waveAmp = parseFloat(document.getElementById('wave-amp').value) * intensity;
      const waveSpeed = parseFloat(document.getElementById('wave-speed').value);
      const pixelate = Math.max(1, parseInt(document.getElementById('pixelate').value) * intensity);
      const contrast = parseInt(document.getElementById('contrast').value) / 100;
      const brightness = parseInt(document.getElementById('brightness').value) / 100;
      const redGain = parseInt(document.getElementById('red-gain').value) / 100;
      const greenGain = parseInt(document.getElementById('green-gain').value) / 100;
      const blueGain = parseInt(document.getElementById('blue-gain').value) / 100;
      const vignette = parseInt(document.getElementById('vignette').value) / 100;
      const sharpen = parseInt(document.getElementById('sharpen').value) / 100;
      const blur = parseInt(document.getElementById('blur').value);

      // Wave Distortion (animated)
      if (waveAmp > 0) {
        waveTime += waveSpeed;
        applyWaveDistortion(imgData, waveFreq, waveAmp, waveTime);
      }

      // Pixelate
      if (pixelate > 1) applyPixelate(imgData, pixelate);

      // Color Adjustments
      adjustContrastBrightness(imgData, contrast, brightness);
      adjustRGBGain(imgData, redGain, greenGain, blueGain);

      // Blur
      if (blur > 0) applyBoxBlur(imgData, blur);

      // Sharpen
      if (sharpen > 0) applySharpen(imgData, sharpen);

      // RGB Shift
      if (rgbShift > 0) applyRGBShift(ctx, imgData, rgbShift);

      // Byte Corruption
      for (let i = 0; i < corruptCount; i++) {
        const idx = Math.floor(Math.random() * (data.length - 3)) & ~3;
        data[idx] = Math.random() * 256 | 0;
        data[idx + 1] = Math.random() * 256 | 0;
        data[idx + 2] = Math.random() * 256 | 0;
      }

      // Pixel Sort
      if (threshold > 0) pixelSort(imgData, threshold);

      // Datamosh
      if (moshStrength > 0) datamosh(imgData, moshStrength);

      // Chromatic Aberration
      if (chromatic > 0) applyChromaticAberration(ctx, imgData, chromatic);

      // Noise
      if (document.getElementById('enable-noise').checked && noiseIntensity > 0) {
        applyNoise(imgData, noiseIntensity);
      }

      // Invert
      if (document.getElementById('enable-invert').checked) invertColors(imgData);

      ctx.putImageData(imgData, 0, 0);

      // Scan Lines
      if (scanLines > 0) applyScanLines(ctx, w, h, scanLines);

      // VHS
      if (document.getElementById('enable-vhs').checked && vhsBleed > 0) {
        applyVHSEffect(ctx, w, h, vhsBleed);
      }

      // Vignette
      if (vignette > 0) applyVignette(ctx, w, h, vignette);

      // Custom Script
      const customCode = document.getElementById('custom-code').value;
      try {
        if (customCode.trim()) {
          imgData = ctx.getImageData(0, 0, w, h);
          const customFunc = new Function('ctx', 'imgData', 'width', 'height', customCode + '; return customGlitch;');
          const userGlitch = customFunc(ctx, imgData, w, h);
          if (typeof userGlitch === 'function') {
            userGlitch(ctx, imgData, w, h);
            ctx.putImageData(imgData, 0, 0);
          }
        }
      } catch (err) {
        console.warn('Custom script error:', err);
        showError('Script error: ' + err.message);
      }

      currentGlitchData = glitchCanvas.toDataURL('image/png');
      downloadBtn.style.display = 'inline-block';
      downloadJpg.style.display = 'inline-block';

      const endTime = performance.now();
      document.getElementById('process-time').textContent = (endTime - startTime).toFixed(2) + ' ms';
    }

    // === NEW GLITCH FUNCTIONS ===
    function applyWaveDistortion(imgData, freq, amp, time) {
      const data = imgData.data;
      const w = imgData.width, h = imgData.height;
      const temp = new Uint8ClampedArray(data);
      for (let y = 0; y < h; y++) {
        const offset = Math.sin((y / freq) + time) * amp;
        for (let x = 0; x < w; x++) {
          const sx = Math.floor((x + offset + w) % w);
          const srcI = (y * w + sx) * 4;
          const destI = (y * w + x) * 4;
          data[destI] = temp[srcI];
          data[destI + 1] = temp[srcI + 1];
          data[destI + 2] = temp[srcI + 2];
        }
      }
    }

    function applyPixelate(imgData, blockSize) {
      const data = imgData.data;
      const w = imgData.width, h = imgData.height;
      blockSize = Math.floor(blockSize);
      for (let y = 0; y < h; y += blockSize) {
        for (let x = 0; x < w; x += blockSize) {
          const i = (y * w + x) * 4;
          if (i >= data.length) continue;
          const r = data[i], g = data[i+1], b = data[i+2];
          for (let dy = 0; dy < blockSize && y + dy < h; dy++) {
            for (let dx = 0; dx < blockSize && x + dx < w; dx++) {
              const idx = ((y + dy) * w + (x + dx)) * 4;
              data[idx] = r; data[idx+1] = g; data[idx+2] = b;
            }
          }
        }
      }
    }

    function adjustContrastBrightness(imgData, contrast, brightness) {
      const data = imgData.data;
      const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.max(0, Math.min(255, factor * (data[i] - 128) + 128 + (brightness - 1) * 128));
        data[i+1] = Math.max(0, Math.min(255, factor * (data[i+1] - 128) + 128 + (brightness - 1) * 128));
        data[i+2] = Math.max(0, Math.min(255, factor * (data[i+2] - 128) + 128 + (brightness - 1) * 128));
      }
    }

    function adjustRGBGain(imgData, r, g, b) {
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.max(0, Math.min(255, data[i] * r));
        data[i+1] = Math.max(0, Math.min(255, data[i+1] * g));
        data[i+2] = Math.max(0, Math.min(255, data[i+2] * b));
      }
    }

    function applyVignette(ctx, w, h, strength) {
      const gradient = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h) / 2);
      gradient.addColorStop(0, 'rgba(0,0,0,0)');
      gradient.addColorStop(1, `rgba(0,0,0,${strength})`);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, w, h);
    }

    function applyBoxBlur(imgData, radius) {
      const data = imgData.data;
      const w = imgData.width, h = imgData.height;
      const temp = new Uint8ClampedArray(data);
      radius = Math.floor(radius);
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          let r = 0, g = 0, b = 0, count = 0;
          for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                const i = (ny * w + nx) * 4;
                r += temp[i]; g += temp[i+1]; b += temp[i+2]; count++;
              }
            }
          }
          const i = (y * w + x) * 4;
          data[i] = r / count; data[i+1] = g / count; data[i+2] = b / count;
        }
      }
    }

    function applySharpen(imgData, amount) {
      const data = imgData.data;
      const w = imgData.width, h = imgData.height;
      const temp = new Uint8ClampedArray(data);
      const weight = amount * 5;
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const i = (y * w + x) * 4;
          for (let c = 0; c < 3; c++) {
            const center = temp[i + c];
            const sum = -temp[(y-1)*w + (x-1)*4 + c] - temp[(y-1)*w + x*4 + c] - temp[(y-1)*w + (x+1)*4 + c]
                      - temp[y*w + (x-1)*4 + c] + center * 9 - temp[y*w + (x+1)*4 + c]
                      - temp[(y+1)*w + (x-1)*4 + c] - temp[(y+1)*w + x*4 + c] - temp[(y+1)*w + (x+1)*4 + c];
            data[i + c] = Math.max(0, Math.min(255, center + sum * amount));
          }
        }
      }
    }

    // === ORIGINAL GLITCH FUNCTIONS (unchanged) ===
    function applyRGBShift(ctx, imgData, shift) {
      const w = imgData.width, h = imgData.height;
      const original = new Uint8ClampedArray(imgData.data);
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;
          const redX = Math.min(x + shift, w - 1), redI = (y * w + redX) * 4;
          const blueX = Math.max(x - shift, 0), blueI = (y * w + blueX) * 4;
          imgData.data[i] = original[redI];
          imgData.data[i + 2] = original[blueI + 2];
        }
      }
    }

    function applyChromaticAberration(ctx, imgData, amount) {
      const w = imgData.width, h = imgData.height;
      const original = new Uint8ClampedArray(imgData.data);
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;
          const offset = Math.sin(y / 10) * amount;
          const offsetX = Math.max(0, Math.min(w - 1, x + offset));
          const offsetI = (y * w + Math.floor(offsetX)) * 4;
          imgData.data[i] = original[offsetI];
          imgData.data[i + 2] = original[i + 2];
        }
      }
    }

    function applyNoise(imgData, intensity = 0.3) {
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        if (Math.random() < intensity) {
          const noise = (Math.random() - 0.5) * 150;
          data[i] = Math.max(0, Math.min(255, data[i] + noise));
          data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
          data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
        }
      }
    }

    function invertColors(imgData) {
      const data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2];
      }
    }

    function applyScanLines(ctx, w, h, intensity) {
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.lineWidth = 1;
      const spacing = Math.max(1, 15 - intensity);
      for (let y = 0; y < h; y += spacing) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }
    }

    function applyVHSEffect(ctx, w, h, bleedStrength) {
      for (let i = 0; i < 8; i++) {
        const y = Math.random() * h;
        const height = 5 + Math.random() * 30;
        const displacement = (Math.random() - 0.5) * 50;
        const imgData = ctx.getImageData(0, y, w, height);
        ctx.putImageData(imgData, displacement, y);
      }
      const imgData = ctx.getImageData(0, 0, w, h);
      const data = imgData.data;
      for (let y = 0; y < h; y += 2) {
        for (let x = 0; x < w - 1; x++) {
          const i = (y * w + x) * 4;
          const nextI = (y * w + x + 1) * 4;
          const bleed = bleedStrength / 20;
          data[nextI] = data[i] * (1 - bleed) + data[nextI] * bleed;
          data[nextI + 1] = data[i + 1] * (1 - bleed) + data[nextI + 1] * bleed;
        }
      }
      ctx.putImageData(imgData, 0, 0);
    }

    function pixelSort(imgData, threshold) {
      const data = imgData.data;
      const w = imgData.width, h = imgData.height;
      for (let y = 0; y < h; y++) {
        let start = -1;
        for (let x = 0; x <= w; x++) {
          const i = (y * w + x) * 4;
          const brightness = x < w ? (data[i] + data[i+1] + data[i+2]) / 3 : 0;
          if (brightness > threshold) {
            if (start === -1) start = x;
          } else {
            if (start !== -1) {
              sortRowSegment(data, y, start, x - 1, w);
              start = -1;
            }
          }
        }
      }
    }

    function sortRowSegment(data, y, x1, x2, rowWidth) {
      const segment = [];
      for (let x = x1; x <= x2; x++) {
        const i = (y * rowWidth + x) * 4;
        segment.push([data[i], data[i+1], data[i+2], data[i+3], i]);
      }
      segment.sort((a, b) => (a[0] + a[1] + a[2]) - (b[0] + b[1] + b[2]));
      segment.forEach((px) => {
        const i = px[4];
        data[i] = px[0]; data[i+1] = px[1]; data[i+2] = px[2]; data[i+3] = px[3];
      });
    }

    function datamosh(imgData, strength) {
      const data = imgData.data;
      const w = imgData.width, h = imgData.height;
      for (let i = 0; i < strength; i++) {
        const blockX = (Math.random() * (w - 50)) | 0;
        const blockY = (Math.random() * (h - 50)) | 0;
        const bw = 20 + (Math.random() * 40) | 0;
        const bh = 20 + (Math.random() * 40) | 0;
        const dx = (Math.random() * 60 - 30) | 0;
        const dy = (Math.random() * 60 - 30) | 0;

        const sourceX = Math.max(0, Math.min(w - bw, blockX));
        const sourceY = Math.max(0, Math.min(h - bh, blockY));
        const destX = Math.max(0, Math.min(w - bw, blockX + dx));
        const destY = Math.max(0, Math.min(h - bh, blockY + dy));

        for (let y = 0; y < bh; y++) {
          for (let x = 0; x < bw; x++) {
            const srcIdx = ((sourceY + y) * w + (sourceX + x)) * 4;
            const destIdx = ((destY + y) * w + (destX + x)) * 4;
            if (destIdx < data.length) {
              data[destIdx] = data[srcIdx];
              data[destIdx+1] = data[srcIdx+1];
              data[destIdx+2] = data[srcIdx+2];
            }
          }
        }
      }
    }

    // === UI & PRESETS ===
    function updateAllValues() {
      document.getElementById('intensity-val').textContent = document.getElementById('intensity').value;
      document.getElementById('rgb-val').textContent = document.getElementById('rgb-shift').value;
      document.getElementById('corrupt-val').textContent = document.getElementById('corrupt-intensity').value;
      document.getElementById('sort-val').textContent = document.getElementById('sort-threshold').value;
      document.getElementById('mosh-val').textContent = document.getElementById('mosh-strength').value;
      document.getElementById('scan-val').textContent = document.getElementById('scan-lines').value;
      document.getElementById('chroma-val').textContent = document.getElementById('chromatic').value;
      document.getElementById('noise-val').textContent = document.getElementById('noise-intensity').value;
      document.getElementById('vhs-val').textContent = document.getElementById('vhs-bleed').value;
      document.getElementById('wave-freq-val').textContent = document.getElementById('wave-freq').value;
      document.getElementById('wave-amp-val').textContent = document.getElementById('wave-amp').value;
      document.getElementById('wave-speed-val').textContent = document.getElementById('wave-speed').value;
      document.getElementById('pixelate-val').textContent = document.getElementById('pixelate').value;
      document.getElementById('contrast-val').textContent = document.getElementById('contrast').value;
      document.getElementById('brightness-val').textContent = document.getElementById('brightness').value;
      document.getElementById('red-gain-val').textContent = document.getElementById('red-gain').value;
      document.getElementById('green-gain-val').textContent = document.getElementById('green-gain').value;
      document.getElementById('blue-gain-val').textContent = document.getElementById('blue-gain').value;
      document.getElementById('vignette-val').textContent = document.getElementById('vignette').value;
      document.getElementById('sharpen-val').textContent = document.getElementById('sharpen').value;
      document.getElementById('blur-val').textContent = document.getElementById('blur').value;
      document.getElementById('jpg-quality-val').textContent = document.getElementById('jpg-quality').value;
    }

    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = presets[btn.dataset.preset];
        if (!preset) return;
        Object.keys(preset).forEach(key => {
          const el = document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase());
          if (el && el.type === 'checkbox') el.checked = preset[key];
          else if (el) el.value = preset[key];
        });
        updateAllValues();
        waveTime = 0;
        applyGlitch();
      });
    });

    const sliders = [
      'intensity', 'rgb-shift', 'corrupt-intensity', 'sort-threshold', 'mosh-strength',
      'scan-lines', 'chromatic', 'noise-intensity', 'vhs-bleed', 'wave-freq', 'wave-amp',
      'wave-speed', 'pixelate', 'contrast', 'brightness', 'red-gain', 'green-gain',
      'blue-gain', 'vignette', 'sharpen', 'blur', 'jpg-quality'
    ];
    sliders.forEach(id => {
      document.getElementById(id).addEventListener('input', () => {
        updateAllValues();
        if (document.getElementById('real-time').checked && originalImage) {
          clearTimeout(realTimeTimeout);
          realTimeTimeout = setTimeout(applyGlitch, 100);
        }
      });
    });

    ['enable-noise', 'enable-vhs', 'enable-invert', 'real-time'].forEach(id => {
      document.getElementById(id).addEventListener('change', () => {
        if (document.getElementById('real-time').checked && originalImage) applyGlitch();
      });
    });

    document.getElementById('apply-glitch').addEventListener('click', applyGlitch);
    document.getElementById('random-glitch').addEventListener('click', () => {
      if (!originalImage) return;
      const rand = (min, max, step = 1) => Math.floor(Math.random() * ((max - min) / step + 1)) * step + min;
      const randFloat = (min, max, prec = 0.1) => +(Math.random() * (max - min) + min).toFixed(1);

      document.getElementById('intensity').value = rand(50, 200);
      document.getElementById('rgb-shift').value = rand(0, 100);
      document.getElementById('corrupt-intensity').value = rand(0, 20000, 100);
      document.getElementById('sort-threshold').value = rand(0, 255);
      document.getElementById('mosh-strength').value = rand(0, 50);
      document.getElementById('scan-lines').value = rand(0, 15);
      document.getElementById('chromatic').value = rand(0, 50);
      document.getElementById('noise-intensity').value = rand(0, 100);
      document.getElementById('vhs-bleed').value = rand(0, 20);
      document.getElementById('wave-freq').value = rand(1, 50);
      document.getElementById('wave-amp').value = rand(0, 60);
      document.getElementById('wave-speed').value = randFloat(0, 5);
      document.getElementById('pixelate').value = rand(1, 50);
      document.getElementById('contrast').value = rand(50, 200);
      document.getElementById('brightness').value = rand(50, 200);
      document.getElementById('red-gain').value = rand(0, 200);
      document.getElementById('green-gain').value = rand(0, 200);
      document.getElementById('blue-gain').value = rand(0, 200);
      document.getElementById('vignette').value = rand(0, 100);
      document.getElementById('sharpen').value = rand(0, 100);
      document.getElementById('blur').value = rand(0, 20);
      document.getElementById('jpg-quality').value = rand(50, 100);

      document.getElementById('enable-noise').checked = Math.random() > 0.3;
      document.getElementById('enable-vhs').checked = Math.random() > 0.5;
      document.getElementById('enable-invert').checked = Math.random() > 0.7;

      updateAllValues();
      waveTime = 0;
      applyGlitch();
    });

    document.getElementById('reset').addEventListener('click', () => {
      if (originalImage) {
        resetGlitch();
        downloadBtn.style.display = 'none';
        downloadJpg.style.display = 'none';
      }
    });

    downloadBtn.addEventListener('click', () => {
      if (currentGlitchData) {
        const link = document.createElement('a');
        link.href = currentGlitchData;
        link.download = 'glitch-art-' + Date.now() + '.png';
        link.click();
        showSuccess('PNG downloaded!');
        setTimeout(() => showSuccess(''), 2000);
      }
    });

    downloadJpg.addEventListener('click', () => {
      if (glitchCanvas) {
        const quality = parseInt(document.getElementById('jpg-quality').value) / 100;
        const link = document.createElement('a');
        link.href = glitchCanvas.toDataURL('image/jpeg', quality);
        link.download = 'glitch-art-' + Date.now() + '.jpg';
        link.click();
        showSuccess('JPG downloaded!');
        setTimeout(() => showSuccess(''), 2000);
      }
    });

    function showError(msg) { errorMsg.textContent = msg; if (msg) setTimeout(() => showError(''), 5000); }
    function showSuccess(msg) { successMsg.textContent = msg; }

    // === INIT ===
    updateAllValues();
    setupUploadHandlers();

    document.getElementById('custom-code').value = `// Trippy wave distortion
function customGlitch(ctx, imgData, width, height) {
  const data = imgData.data;
  const temp = new Uint8ClampedArray(data);
  for (let y = 0; y < height; y++) {
    const offset = Math.sin(y / 15) * 20;
    for (let x = 0; x < width; x++) {
      const sourceX = Math.floor((x + offset + width) % width);
      const sourceI = (y * width + sourceX) * 4;
      const destI = (y * width + x) * 4;
      data[destI] = temp[sourceI];
      data[destI + 1] = temp[sourceI + 1];
      data[destI + 2] = temp[sourceI + 2];
    }
  }
}`;
  </script>
</body>
</html>
